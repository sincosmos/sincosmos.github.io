---
layout:     post
title:      领域驱动设计实践
subtitle:   微博粉丝经济架构设计
date:       2020-03-17
author:     sincosmos
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - 领域驱动设计
---  

## 领域驱动设计的基本概念

### 实体(Entity)
实体就是领域中需要唯一标识的领域概念。因为我们有时需要区分是哪个实体。有两个实体，如果唯一标识不一样，那么即便实体的其他所有属性都一样，我们也认为他们两个不同的实体；因为实体有生命周期，实体从被创建后可能会被持久化到数据库，然后某个时候又会被取出来。所以，如果我们不为实体定义一种可以唯一区分的标识，那我们就无法区分到底是这个实体还是哪个实体。另外，不应该给实体定义太多的属性或行为，而应该寻找关联，发现其他一些实体或值对象，将属性或行为转移到其他关联的实体或值对象上。比如Customer实体，他有一些地址信息，由于地址信息是一个完整的有业务含义的概念，所以，我们可以定义一个Address对象，然后把Customer的地址相关的信息转移到Address对象上。如果没有Address对象，而把这些地址信息直接放在Customer对象上，并且如果对于一些其他的类似Address的信息也都直接放在Customer上，会导致Customer对象很混乱，结构不清晰，最终导致它难以维护和理解。

### 值对象(Value Object)
在领域中，并不是没一个事物都必须有一个唯一标识，也就是说我们不关心对象是哪个，而只关心对象是什么。就以上面的地址对象Address为例，如果有两个Customer的地址信息是一样的，我们就会认为这两个Customer的地址是同一个。也就是说只要地址信息一样，我们就认为是同一个地址。用程序的方式来表达就是，如果两个对象的所有的属性的值都相同我们会认为它们是同一个对象的话，那么我们就可以把这种对象设计为值对象。因此，值对象没有唯一标识，这是它和实体的最大不同。值对象另外一个明显的特征是不可变，即所有属性都是只读的。因为属性是只读的，所以可以被安全的共享；当共享值对象时，一般有复制和共享两种做法，具体采用哪种做法还要根据实际情况而定；另外，我们应该给值对象设计的尽量简单，不要让它引用很多其他的对象，因为他只是一个值，就像int a = 3;那么”3”就是一个我们传统意义上所说的值，而值对象其实也可以和这里的”3”一样理解，也是一个值，只不过是用对象来表示。
值对象虽然是只读的，但是可以被整个替换掉。当你要修改Customer的Address对象引用时，不是通过Customer.Address.Street这样的方式来实现，因为值对象是只读的，它是一个完整的不可分割的整体。我们可以这样做：Customer.Address = new Address(…)。

### 聚合(Aggregate)
聚合Aggregate就是一组相关对象的集合，它通过定义对象之间清晰的所属关系和边界来实现领域模型的内聚，我们把它作为数据修改和访问的单元。
一个聚合包含聚合根、实体和值对象。聚合根也是实体，但它特殊在它的实体唯一标识也同时标识了它所在的聚合。聚合根相当于主Entity，子实体都不可能孤立存在，它们必须依附于一个聚合根存在。
每个聚合都会有一个聚合根和聚合的边界Boundary，边界定义了在一个聚合里面内部应该有哪些实体，哪些子实体对象。定义边界的原因是我们期望对一个聚合的访问是通过聚合根点进行的，聚合里面的子实体对外界是完全封闭的。对于外部对象不应该去访问到一个聚合边界里面的子实体。
聚合内部的对象之间可以相互引用，但是聚合外部如果要访问聚合内部的对象时，必须通过聚合根开始导航，绝对不能绕过聚合根直接访问聚合内的对象。
聚合设计的原则：
1) 聚合是用来封装真正的不变性，而不是简单的将对象组合在一起；
2) 聚合应尽量设计的小；
3) 聚合之间的关联通过ID，而不是对象引用；
4) 聚合内强一致性，聚合之间最终一致性。
5) 聚合根内部的所有变更都必须通过聚合根完成。为了保证聚合根的一致性，同时避免聚合根内部逻辑向外泄露，客户方只能将整个聚合根作为统一调用入口。
6) 聚合根不应该引用基础设施。
7) 外界不应该持有聚合根内部的数据结构。


## 领域驱动设计的经典分层架构
![领域驱动设计](https://images0.cnblogs.com/blog/13665/201311/07230316-6cddb04bdbf840e18b06e466a613de50.png)

### 用户界面/展现层
负责向用户展示信息及接收用户交互命令。即 1) 请求应用层以获取用户所需的数据并予以展现; 2) 接收用户命令并发送给应用层，要求其执行某个用户命令。结合 CQRS (命令/查询职责分离)模式，第一点是用户查询请求的入口，第二点是用户命令请求的入口。

### 应用层
很薄的一层，定义软件要完成的所有任务，对外为展现层提供各种应用功能（查询/命令)，对内调用领域层（领域对象或领域服务）完成各种业务逻辑。应层本身不包含业务逻辑。

### 领域层
负责表达业务概念，业务状态信息和业务规则，领域模型处于这一层，是业务软件的核心。

### 基础设施层
本层为其它层提供通用的技术能力；提供层间通信的基础设施；为领域层实现持久化机制。总之，基础设施层可以通过其它框架来支持其它层的技术需求。

## 应用层服务、领域服务、基础服务
上面的分层架构中，除了展现层，都会提供 Service 功能。
在领域层中，一些概念不适合建模为 Entity，也不适合作为 Value Object，因为它们本质上就是一些操作，一些策略，而不是事物。这些操作往往会涉及到多个领域对象，并且需要协调这些领域对象共同完成。所以就有了领域服务这个模式，封装领域内的业务操作。这样一来，处理复杂业务时，应用层也能调用领域服务，避免领域逻辑外泄。
下面以转账为例，看一下各层服务的职责及它们之间是如何配合工作的。

### 应用层服务
1. 获取输入（例如一个转账请求)
2. 发送消息（含入参）给领域层服务，要求其实现转账的业务逻辑
3. 领域层服务处理转账请求成功，调用基础层服务发送 Email 通知

### 领域层服务
1. 获取源账号和目标账号对象实例，分别进行扣除金额和增加金额的操作
2. 提供返回结果（转账成功）给应用层

### 基础层服务
1. 按照应用层请求，发送 Email 通知

### 服务交互
从经典的领域驱动设计分层架构中可以看出，领域层的上层是应用层，下层是基础设施层。那么领域层是如何与其它层交互的呢？
#### 查询
查询指不会影响领域层中领域对象状态的查询功能。
可以直接通过仓储查询出所需要的数据。但一般领域层中的仓储提供的查询功能也许不能满足界面显示的需要，则可能需要多次调用不同的仓储才能获取所需要显示的数据；其实针对这种查询的情况，可以直接通过CQRS的架构来实现。即对于查询，我们可以在应用层不调用领域层的任何东西，而是直接通过某个其他的用另外的技术架构实现的查询引擎来完成查询，比如直接通过构造参数化SQL的方式从数据库一个表或多个表中查询出任何想要显示的数据。这样不仅性能高，也可以减轻领域层的负担。领域模型不太适合为应用层提供各种查询服务，因为往往界面上要显示的数据是很多对象的组合信息，是一种非对象概念的信息，就像报表；
#### 命令
命令指会影响领域层中领域对象状态的应用层功能。
一般应用层会先启动一个工作单元，然后：
对于修改领域对象的情况，通过仓储获取领域对象，调用领域对象的相关业务方法以完成业务逻辑处理；
对于新增领域对象的情况，通过构造函数或工厂创建出领域对象，如果需要还可以继续对该新创建的领域对象做一些操作，然后把该新创建的领域对象添加到仓储中；
对于删除领域对象的情况，可以先把领域对象从仓储中取出来，然后将其从仓储中删除，也可以直接传递一个要删除的领域对象的唯一标识给仓储通知其移除该唯一标识对应领域对象；
如果一个业务逻辑涉及到多个领域对象，则调用领域层中的相关领域服务完成操作；
注意，以上所说的所有领域对象都是只聚合根，另外在应用层需要获取仓储接口以及领域服务接口时，都可以通过IOC容器获取。最后通知工作单元提交事务从而将所有相关的领域对象的状态以事务的方式持久化到数据库；

## 领域事件
一个业务用例对应一个事务，一个事务对应一个聚合根，也即在一次事务中，只能对一个聚合根进行操作。但是在实际应用中，我们经常发现一个用例需要修改多个聚合根的情况，并且不同的聚合根还处于不同的限界上下文中。比如，当你在电商网站上买了东西之后，你的积分会相应增加。这里的购买行为可能被建模为一个订单（Order）对象，而积分可以建模成账户（Account）对象的某个属性，订单和账户均为聚合根，并且分别属于订单系统和账户系统。显然，我们需要在订单和积分之间维护数据一致性，然而在同一个事务中同时更新两者又违背了DDD设计原则，并且此时需要在两个不同的系统之间采用重量级的分布式事务（Distributed Transactioin，也叫XA事务或者全局事务）。另外，这种方式还在订单系统和账户系统之间产生了强耦合。通过引入领域事件，我们可以很好地解决上述问题。


## Event Sourcing 和 CQRS
[Event Sourcing 和 CQRS 落地](https://www.infoq.cn/article/JmiZRu85W7i4W-HsoX5t)
Event Sourcing 简单来说就是记录对象的每个事件而不是记录对象的最新状态，比如新建、修改等，只记录事件内容，当需要最新的状态的时，通过堆叠事件将最新的状态计算出来。那么这种模式查询的时候性能会变的非常差，这个时候就涉及到了 CQRS ，简单的理解就是读写分离，通过事件触发，将最新状态保存到读库，查询全都走读库。这样数据变更通过事件记录，同时最新状态保存到读库，供查询。

Commond 实例相当于应用入参
Event 实例是

## 参考资料
1. [领域驱动设计之领域模型](https://www.cnblogs.com/netfocus/archive/2011/10/10/2204949.html)

