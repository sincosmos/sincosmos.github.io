---
layout:     post
title:      微服务技术
subtitle:   学习笔记
date:       2019-11-07
author:     sincosmos
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - Kubernetes, ServiceMesher, Istio
---  

## 微服务之间的交互
### 交互方式
单体应用将所有的功能模块聚集到同一个服务，各个模块之间直接通过代码调用彼此的功能。微服务将各个功能模块拆分成不同的微服务，模块间的功能调用就变成了跨服务的调用。微服务之间主要有三种调用方式。
1. Restful API 调用
2. RPC 调用
3. ED (Event-Driven)
前两种比较类似，请求方知道服务方的服务地址，按照要求发起请求并获得结果。
事件驱动的方式，把请求者与被请求者解耦，以一个消息队列连接二者。例如，请求方将请求相关信息发送到消息队列约定 topic，服务方监听消息队列相应 topic 并进行处理。
上述三种方式都使得原来单体服务的事务操作无法起到原来的作用。
从调用时效划分，微服务间有如下的调用模式
1. 同步调用模式。微服务调用其它服务时阻塞等待其它服务的返回结果，或者服务调用超时。
2. 接口异步调用模式。服务1调用服务2执行某项任务，服务2接到请求后立即返回服务1受理结果。如果受理成功，则服务1继续进行后续操作，服务2异步地执行这项任务，完成后回调告知服务1任务执行成功，服务1则根据此回调消息做后续处理。
3. 消息队列异步处理模式。和接口异步调用的模式不同，服务1需要服务2执行某项任务时，其只将某种事件消息（通过消息队列）传递给服务2，而不需要依赖服务2返回结果。
一般地，1) 我们需要尽量使用异步来替换同步操作; 2) 同时，能用同步解决的问题，不要引入异步。这两个原则似乎有矛盾，但其立场不同，第一条原则是业务功能角度出发，如果业务逻辑允许，则我们尽可能采用异步解耦来降低核心链路的复杂度。第二条原则是从技术和架构角度出发，这条原则应用的前提是同步能够解决问题（性能问题、扩展性问题等），例如访问数据库的操作无论是查询还是更新，都不需要异步化。

### 设计模式
1. 读者容错模式，指微服务间服务提供者和消费者之间对通过接口传输的数据的格式、字段和内容进行容错。
2. 消费者驱动契约模式。如提供者契约指以服务提供者为中心，各消费者无条件遵守提供者提供的功能和消息格式；类似的还有消费者契约和消费者驱动契约。
3. 去数据共享模式，即在为服务领域，微服务之间的交互通过接口调用或消息队列来传递，不允许使用共享数据（数据库或者缓存）。

## 微服务的分解与组合
1. 在微服务架构的需求分析和架构设计过程中，通常是用领域的动词和名词来划分微服务的。
2. 同时可以在 facade 服务层组合微服务进行服务聚合。例如电商交易系统中，商品、购物车、订单、支付等每一个模块被划分为一个微服务，而从前端的角度，一个购物请求的完成可能需要多个微服务协作完成，那么 facade 服务层可以作为前端接入层，按照顺序调用依赖的多个微服务，并对其返回的数据进行组合、加工和转换，最后以约定的形式返回给使用方。聚合服务自身可以有数据库或缓存，也可以只做数据转换。
3. 为了完成某个功能，微服务之间也可以串联调用，例如订单服务可能会调用支付服务完成下单操作。
4. 另外，上述的服务调用都是用同步调用，如果提供方迟迟没有返回，会导致消费方阻塞或超时失败，因此在构建微服务调用链时，通常会梳理出核心系统的最小化服务集合，这些服务间采用同步调用，而其他服务可以采用异步消息队列进行解耦。
5. 在设计模式一节，提到不允许使用共享数据进行服务交互，但在某些特殊场景（单元化架构、遗留的整体服务）下，可以让不同的微服务暂时使用共享数据。
6. 切记不要在本地事务过程中调用远程服务。

## 分布式系统的一致性问题
### 最终一致性的实现
在分布式系统中，一个业务操作可能由多个微服务协作完成，为了保证业务正确实施，必须要保证各个参与的微服务最终状态的一致性。如果采用分布式协议例如两阶段提交或三阶段提交，虽然能实现最终一致性，但其成本很高，难以实现。现实系统中，微服务间实现最终一致性有一些非常有效的、简单的模式。
1. 查询模式。任务服务操作都提供一个查询接口，用来向外部输出操作执行的状态，同时为了准确定位操作，每个业务操作都要有唯一的流水标识，常用的例如请求流水号、订单号等。查询可由业务发起方服务进行。
2. 补偿模式。根据查询模式给出的操作状态，对业务操作进行补偿，例如回滚某些微服务的子操作或重新执行某些微服务的子操作。重复执行某些微服务操作，需要保证服务执行要具有幂等性。
3. 异步确保模式。该模式是补偿模式的一个典型案例，经常应用到使用方对响应时间要求不太高的场景，通常把这类操作从主流程中摘除，通过一步的方式进行处理。
4. 定期校对模式

### 微服务交互超时问题的解决方案
1. 同步调用模式下的解决方案

## 分布式系统非功能性指标
非功能质量需求的具体指标针对不同的系统主要分为 4 个部分：应用服务器、数据库、缓存和消息队列。
### 应用服务器
应用服务器是服务的入口，请求的流量从这里进入系统，数据库、缓存和消息队列的访问量取决于服务器的访问量。  
应用服务器的衡量指标有以下几类。
1. 部署结构
负载均衡策略，高可用策略，I/O 模型，线程池模型，线程池中线程数量等
2. 容量和性能
日均请求量，各接口 QPS，平均请求响应时间，最大请求响应时间，在线用户量等
3. 其它指标
请求内容是否包含大对象，GC 收集器选型和配置
### 数据库
1. 部署结构
复制模型、失效转移策略、容灾策略、归档策略、读写分离策略、分库分表策略、静态数据和半静态数据是否使用缓存、缓存击穿数据库压力响应策略、缓存失效和缓存数据预热策略
2. 容量和性能
当前的数据容量、数据日增量、读/写峰值、事务峰值
3. 其它相关指标
查询是否走索引、有没有大数据量的查询和范围查询、多表关联及关联字段索引、事务和一致性级别
### 缓存
1. 部署结构
复制模型、失效转移、持久化策略、缓存淘汰策略、线程模型、预热方法、哈希分片策略
2. 容量和性能
缓存内容大小、缓存内容数量、缓存内容国旗时间、缓存内容数据结构与序列化、读/写峰值
3. 其它指标
冷热数据比例、是否可能发生缓存穿透、是否有大对象、是否使用缓存使用分布式锁、是否使用缓存脚本（Lua）、是否避免了 Race Condition
### 消息队列
1. 部署结构
复制模型、失效转移、持久化策略
2. 容量和性能
每天平均的数据增量、消息持久的过期时间、读/写峰值、每条消息的大小、平均延迟、最大延迟
3. 其它相关指标
消费者线程池模型、哈希分片策略、消息的可靠投递、消费者的处理流程和持久机制


## ServiceMesher(服务网格)  
1. 服务网格是用于处理服务间通信的专用基础设施层  
2. 服务网格中分为控制平面和数据平面，当前流行的两款开源服务网格 Istio 和 Linkerd 实际上都是这种构造。  
   ![服务网格架构](https://jimmysong.io/istio-handbook/images/0069RVTdly1fuail4d24jj31080rkgr7.jpg)  
   控制平面不直接解析数据包；与控制平面中的代理通信，下发策略和配置；负责网络行为的可视化；通常提供 API 或者命令行工具可用于配置版本化管理，便于持续集成和部署。  
   数据平面通常是按照无状态目标设计的，但实际上位了提高流量转发性能，需要缓存一些数据，因此无状态也是有争议的；直接处理入站和出站的数据包，转发、路由、健康检查、负载均衡、认证、鉴权、产生监控数据；对应用来说是透明的，可以做到无感知部署。
   
## Istio
1. Istio 可以在虚拟机和容器中运行。  
2. Istio 的组成
- Pilot: 服务发现，流量管理
- Mixer: 访问控制，遥测
- Citadel: 终端用户认证、流量加密
Istio 作为控制平面，在每个服务中注入一个 Envoy 代理以 Sidecar 形式运行，拦截所有进出服务的流量，同事对流量加以控制。而服务对该代理是无感知的。应用程序（服务）应关注于业务逻辑，非功能需求交给 Service Mesh。  
3. Sidecar 模式，为每一个应用容器部署一个伴生容器，以 Kubernetes 集群中的应用为例，会在每一个 Pod 中运行一个 Sidecar 容器，与 Pod 中的应用容器共享存储和网络资源，类似每一个 Pod 中都运行着的 pause 容器，只不过 Sidecar 容器有其独特的作用。
   ![SOFAMesh](https://jimmysong.io/istio-handbook/images/006tNbRwgy1fuyr4vizzwj31kw1biq98.jpg)    
   例如图中，MOSN 作为 Sidecar 的方式和应用运行在同一个 Pod 中，拦截所有进出应用容器的流量，SOFAMesh 兼容 Istio，其中使用 Go 语言开发的 SOFAMosn 替换了 Envoy。
4. Sidecar 容器的流量劫持是通过 iptables 转发实现的。   

## Java Project on Kubernetes
[Sample java web system on Kubernetes](https://medium.com/@dayan888/sample-java-web-system-on-kubernetes-e52069390916)
[Debug Java Application on Kubernetes](https://dev.to/sandrogiacom/kubernetes-for-java-developers-debug-application-4l1a)

## Mircoservice without Kubernetes
[Microservice Architectures With Spring Cloud and Docker](https://dzone.com/articles/microservice-architecture-with-spring-cloud-and-do)

## Spring Cloud 微服务常见组件
Spring Cloud 是一种微服务规范，它规定了微服务架构的基本组件的类型，不同的微服务实现，采用的基本组件可能不一样。
Spring Cloud 规定微服务需要以下组件。
1. 服务网关，例如 Zuul, Spring Cloud Gateway
2. 服务注册与发现，例如 Eureka, Consul, Nacos
3. 配置中心, 例如 Spring Cloud Config
4. 服务容错管理，例如 Hystrix
5. 服务调用，例如 Feign, Dubbo
6. 日志收集，例如 Spring Cloud Sleuth+ELK, fluentd/Istio, LogStash
7. 调用链监控，skywalking
8. metrics监控：prometheus+spring actuator

Kubernetes 中相对应的组件，可以参见下表  

|   关注点    |   Spring Cloud | Kubernetes |
| :-----------| :---------- | :----------  |
| 自愈和自动伸缩 | 无 | kube-controller-manager |
| 调度和发布 	 | 无 	| kube-scheduler+Deployment  |
| 配置管理 		| Spring Cloud Config/Nacos |  ConfigMap |
| 服务发现和LB  | Eureka/Nacos | Service+CoreDNS/Istio   |
| 弹性和容错 	 | Hystrix/Resillience4j 	| Istio     |
| API网关 	    | Zuul/Spring Cloud Gateway  | Ingress/Istio Gateway |
| 服务安全 	    | Spring Cloud Security 	|  Istio |
| 调用链监控 	 | Spring Cloud Sleuth+ZipKin  | Istio+Jaeger/ZipKin  |
| Metrics监控  | actuator+Spring Boot Admin  | Istio+Prometheus |
| 日志收集 		| Spring Cloud Sleuth+ELK 	    | fluentd/Istio |


